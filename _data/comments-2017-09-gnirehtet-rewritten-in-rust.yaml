- id: 1
  author: Ralf
  date: 2017-09-21 20:25:55+02:00
  contents: |
    > In C and C++, infinite loops without side-effects are undefined behavior.

    Actually, in C (unlike C++), such loops are only UB if the loop condition is
    not a constant expression.  However, LLVM fails to implement this exception
    as is thus breaking some correct C programs.  This has been reported against
    LLVM already more than ten years ago:
    <https://bugs.llvm.org/show_bug.cgi?id=965>.
- id: 2
  author: Istvan Szekeres
  date: 2017-09-22 15:24:26+02:00
  contents: |
    Is the raw field in IPV4Header (and others) necessary? Are those accessed
    besides reading/writing the whole packet, including those headers?

    If not, why don't just use std::mem::transmute the convert the whole raw
    packet to/from the structs, right after reading / before writing the packet?
- id: 3
  author: ®om
  date: 2017-09-22 16:00:07+02:00
  contents: |
    > @[**Ralf**](#comment-1)
    >
    > Actually, in C (unlike C++), such loops are only UB if the loop condition
    > is not a constant expression.

    Thank you for the precision, I was not aware of this subtlety.

    > @[**Istvan Szekeres**](#comment-2)
    >
    > Is the raw field in IPV4Header (and others) necessary? Are those accessed
    > besides reading/writing the whole packet, including those headers?

    In the device-to-network direction, on new connection, the received headers
    are [copied to a buffer][packetizer-copy], with source and destination
    swapped, so that they are [updated][packetizer-update] (lengths and checksum
    fields) on each packet built for the network-to-device direction.

    [packetizer-copy]: https://github.com/Genymobile/gnirehtet/blob/v2.0/relay-rust/src/relay/packetizer.rs#L46-L58
    [packetizer-update]: https://github.com/Genymobile/gnirehtet/blob/v2.0/relay-rust/src/relay/packetizer.rs#L110-L125
- id: 4
  author: yglukhov
  date: 2017-09-23 00:21:55+02:00
  contents: |
    Thanks for the article, was really a pleasure to read. I wonder if you could
    evaluate Nim lang with the same project of yours.
- id: 5
  author: 0nkery
  date: 2017-09-27 16:37:38+02:00
  contents: |
    Thanks for good article!

    I'm wondering why you didn't implement `EventListener` trait for `Storage`
    struct from your example with `Observer` pattern? Also, you could change a
    signature of `on_event` method to be

    {% highlight rust %}
    pub trait EventListener {
        fn on_event(&mut self, event: u32);
    }
    {% endhighlight %}

    So, your event listeners are free to mutate their state based on given
    event. `Storage` struct greatly benefit from this design.
- id: 6
  author: ®om
  date: 2017-09-27 22:26:43+02:00
  contents: |
    > I'm wondering why you didn't implement `EventListener` trait for `Storage`
    > struct from your example with `Observer` pattern?

    That's an alternative, but it would need to be implemented for
    `Rc<RefCell<Storage>>`.

    > Also, you could change a signature of `on_event` method […]
    >
    > So, your event listeners are free to mutate their state based on given
    > event.

    That's a good question, I hesitated to talk about it in the article.

    The `Notifier` stores the listeners in a `Vec<Box<EventListener>>`. Some of
    them may need to mutate a state, some others may not.

    If you define the trait method with `&mut self`, then the `Notifier` _must_
    store them in a `Vec<Rc<RefCell<Box<EventListener>>>>`, and _always_
    [mutably borrow][borrow_mut] the `RefCell` (which is not free) to call
    `on_event()` on it, for all listeners.

    [borrow_mut]: https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.borrow_mut

    To avoid this extra-cost, it is better to let the listeners borrow only when
    necessary.
